import{_ as s,c as a,a as p,o as e}from"./app-DyHmJYok.js";const t={};function c(l,n){return e(),a("div",null,[...n[0]||(n[0]=[p(`<h1 id="rust-泛型" tabindex="-1"><a class="header-anchor" href="#rust-泛型"><span>rust 泛型</span></a></h1><h2 id="什么是泛型" tabindex="-1"><a class="header-anchor" href="#什么是泛型"><span>什么是泛型</span></a></h2><p>泛型（Generics）是 Rust 中允许我们创建函数签名、结构体和枚举等定义的工具，这些定义可以用于多种不同的具体数据类型。我们可以首先看看如何使用泛型定义函数、结构体、枚举和方法，然后讨论泛型对代码性能的影响。</p><h2 id="函数中的泛型" tabindex="-1"><a class="header-anchor" href="#函数中的泛型"><span>函数中的泛型</span></a></h2><p>在定义使用泛型的函数时，我们将泛型放在函数签名中，也就是通常指定参数和返回值数据类型的位置。这样做使我们的代码更加灵活，并为函数的调用者提供更多功能，同时防止代码重复。</p><p>考虑这两个都查找切片中最大值的函数：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">largest_i32</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">i32</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> largest <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> item <span class="token keyword">in</span> list <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> item <span class="token operator">&gt;</span> largest <span class="token punctuation">{</span></span>
<span class="line">            largest <span class="token operator">=</span> item<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    largest</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">largest_char</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">char</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">char</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> largest <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> item <span class="token keyword">in</span> list <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> item <span class="token operator">&gt;</span> largest <span class="token punctuation">{</span></span>
<span class="line">            largest <span class="token operator">=</span> item<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    largest</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> number_list <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">largest_i32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>number_list<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The largest number is {result}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> char_list <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token char">&#39;y&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;m&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;q&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">largest_char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>char_list<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The largest char is {result}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数体具有相同的代码，所以我们可以引入一个通用的泛型类型参数来合并这两个函数，消除重复。为了对新函数中的类型进行参数化，我们需要命名类型参数，就像对函数的值参数一样。Rust 中的类型参数名称通常是简短的（通常是单个字母），并且遵循驼峰命名法。<code>T</code> 是 &quot;type&quot; 的缩写，是大多数 Rust 程序员的默认选择。</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">largest</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> largest <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> item <span class="token keyword">in</span> list <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> item <span class="token operator">&gt;</span> largest <span class="token punctuation">{</span></span>
<span class="line">            largest <span class="token operator">=</span> item<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    largest</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，此代码还不能编译，因为编译器不知道类型 <code>T</code> 是否支持 &gt; 比较运算符。为了解决这个问题，我们需要限制 <code>T</code> 只能是实现了 <code>PartialOrd</code> trait 的类型：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">largest</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token namespace">std<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">PartialOrd</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token keyword">mut</span> largest <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> item <span class="token keyword">in</span> list <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> item <span class="token operator">&gt;</span> largest <span class="token punctuation">{</span></span>
<span class="line">            largest <span class="token operator">=</span> item<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    largest</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="结构体中的泛型" tabindex="-1"><a class="header-anchor" href="#结构体中的泛型"><span>结构体中的泛型</span></a></h2><p>我们也可以定义使用泛型类型参数的结构体。语法与函数定义中使用的泛型语法类似。首先在结构体名称后面的尖括号中声明类型参数名称，然后在结构体定义中使用泛型类型，而不是具体的数据类型。</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span></span>
<span class="line">    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> integer <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> float <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，因为我们只使用一个泛型类型来定义 <code>Point&lt;T&gt;</code>，这个定义说明 <code>Point&lt;T&gt;</code> 结构体是泛型的，<code>x</code> 和 <code>y</code> 都是相同的类型。如果我们尝试创建一个 <code>x</code> 和 <code>y</code> 具有不同类型的实例，代码将无法编译。</p><p>如果我们想要定义一个 <code>x</code> 和 <code>y</code> 都是泛型但可以有不同类型的 <code>Point</code> 结构体，我们可以使用多个泛型类型参数：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span></span>
<span class="line">    y<span class="token punctuation">:</span> <span class="token class-name">U</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> both_integer <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> both_float <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> integer_and_float <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="枚举中的泛型" tabindex="-1"><a class="header-anchor" href="#枚举中的泛型"><span>枚举中的泛型</span></a></h2><p>与结构体一样，我们可以定义在变体中包含泛型数据类型的枚举。让我们再次看看标准库提供的 <code>Option&lt;T&gt;</code> 枚举：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">None</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个定义现在应该更有意义了。可以看到，<code>Option&lt;T&gt;</code> 枚举是 <code>T</code> 类型的泛型，有两个变体：<code>Some</code>，它包含一个 <code>T</code> 类型的值，以及不包含任何值的 <code>None</code> 变体。</p><p>枚举也可以使用多个泛型类型。<code>Result</code> 枚举的定义就是一个例子：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">enum</span> <span class="token type-definition class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Result</code> 枚举是 <code>T</code> 和 <code>E</code> 两个类型的泛型，有两个变体：<code>Ok</code>，它包含一个 <code>T</code> 类型的值，以及 <code>Err</code>，它包含一个 <code>E</code> 类型的值。这种定义使得我们可以在任何可能成功（返回某种 <code>T</code> 类型的值）或失败（返回某种 <code>E</code> 类型的错误）的操作中方便地使用 <code>Result</code> 枚举。</p><h2 id="方法中的泛型" tabindex="-1"><a class="header-anchor" href="#方法中的泛型"><span>方法中的泛型</span></a></h2><p>我们可以在结构体和枚举上实现方法（就像第五章中所做的那样），并在它们的定义中使用泛型类型。以下是在 <code>Point&lt;T&gt;</code> 结构体上实现名为 <code>x</code> 的方法的例子：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span></span>
<span class="line">    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">fn</span> <span class="token function-definition function">x</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>x</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;p.x = {}&quot;</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，我们必须在 <code>impl</code> 之后声明 <code>T</code>，这样我们才能使用 <code>T</code> 来指定我们正在对 <code>Point&lt;T&gt;</code> 类型实现方法。通过在 <code>impl</code> 之后声明 <code>T</code> 作为泛型类型，Rust 可以识别出尖括号中的 <code>Point</code> 中的类型是泛型类型而不是具体类型。</p><p>我们还可以在定义类型的上的方法时指定对泛型类型的约束。例如，我们可以只为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为任何泛型类型的 <code>Point&lt;T&gt;</code> 实例实现：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">impl</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token keyword">f32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">fn</span> <span class="token function-definition function">distance_from_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f32</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这意味着 <code>Point&lt;f32&gt;</code> 类型将有一个 <code>distance_from_origin</code> 方法；其他 <code>T</code> 不是 <code>f32</code> 的 <code>Point&lt;T&gt;</code> 实例将没有定义此方法。</p><p>下面是一个演示如何在结构体和方法中分别定义泛型参数的完整示例：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    x<span class="token punctuation">:</span> <span class="token constant">X1</span><span class="token punctuation">,</span></span>
<span class="line">    y<span class="token punctuation">:</span> <span class="token constant">Y1</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y1</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">fn</span> <span class="token function-definition function">mixup</span><span class="token operator">&lt;</span><span class="token constant">X2</span><span class="token punctuation">,</span> <span class="token constant">Y2</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X2</span><span class="token punctuation">,</span> <span class="token constant">Y2</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y2</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Point</span> <span class="token punctuation">{</span></span>
<span class="line">            x<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span></span>
<span class="line">            y<span class="token punctuation">:</span> other<span class="token punctuation">.</span>y<span class="token punctuation">,</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token char">&#39;c&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">mixup</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;p3.x = {}, p3.y = {}&quot;</span><span class="token punctuation">,</span> p3<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p3<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们定义了 <code>Point</code> 结构体，其 <code>x</code> 字段类型为 <code>X1</code>，<code>y</code> 字段类型为 <code>Y1</code>。在 <code>impl</code> 块中，我们声明了与结构体定义相关的泛型参数 <code>X1</code> 和 <code>Y1</code>。对于 <code>mixup</code> 方法，我们引入了新的泛型参数 <code>X2</code> 和 <code>Y2</code>，它们独立于结构体的泛型参数。此方法将当前点的 <code>x</code> 值与另一个点的 <code>y</code> 值组合成一个新的 <code>Point</code> 实例。</p><h2 id="使用泛型的代码性能" tabindex="-1"><a class="header-anchor" href="#使用泛型的代码性能"><span>使用泛型的代码性能</span></a></h2><p>在使用泛型类型参数时是否存在运行时成本是值得考虑的问题。使用泛型类型并不会使程序的运行效率低于使用具体类型。</p><p>Rust 通过在编译时对使用泛型的代码执行单态化（monomorphization）来实现这一点。单态化是通过填入编译时使用的具体类型来将泛型代码转换为特定代码的过程。在这个过程中，编译器查看调用泛型代码的所有位置，并为调用泛型代码时使用的具体类型生成代码。</p><p>例如，当我们使用标准库的泛型 <code>Option&lt;T&gt;</code> 枚举时：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">let</span> integer <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> float <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当 Rust 编译这段代码时，它会执行单态化。在这个过程中，编译器读取在 <code>Option&lt;T&gt;</code> 实例中使用的值，并识别出两种类型的 <code>Option&lt;T&gt;</code>：一种是 <code>i32</code>，另一种是 <code>f64</code>。因此，它将展开 <code>Option&lt;T&gt;</code> 的泛型定义为两个针对 <code>i32</code> 和 <code>f64</code> 专门化的定义，从而用特定的定义替换泛型定义。</p><p>单态化后的代码看起来类似于以下（编译器使用与我们这里不同的名称来说明）：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="line"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option_i32</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">None</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option_f64</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">f64</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">None</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> integer <span class="token operator">=</span> <span class="token class-name">Option_i32</span><span class="token punctuation">::</span><span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> float <span class="token operator">=</span> <span class="token class-name">Option_f64</span><span class="token punctuation">::</span><span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>泛型的 <code>Option&lt;T&gt;</code> 被编译器创建的特定定义所替换。因为 Rust 将泛型代码编译为在每个实例中指定类型的代码，所以我们在使用泛型时无需付出运行时成本。当代码运行时，它的性能与我们手动复制每个定义时的性能完全相同。单态化过程使 Rust 的泛型在运行时极其高效。</p>`,43)])])}const i=s(t,[["render",c],["__file","rustfanxing.html.vue"]]),u=JSON.parse('{"path":"/blogs/rust/2025/rustfanxing.html","title":"rust 泛型","lang":"en-US","frontmatter":{"title":"rust 泛型","date":"2025-10-25T00:00:00.000Z","tags":["rust"],"categories":["rust"]},"headers":[{"level":2,"title":"什么是泛型","slug":"什么是泛型","link":"#什么是泛型","children":[]},{"level":2,"title":"函数中的泛型","slug":"函数中的泛型","link":"#函数中的泛型","children":[]},{"level":2,"title":"结构体中的泛型","slug":"结构体中的泛型","link":"#结构体中的泛型","children":[]},{"level":2,"title":"枚举中的泛型","slug":"枚举中的泛型","link":"#枚举中的泛型","children":[]},{"level":2,"title":"方法中的泛型","slug":"方法中的泛型","link":"#方法中的泛型","children":[]},{"level":2,"title":"使用泛型的代码性能","slug":"使用泛型的代码性能","link":"#使用泛型的代码性能","children":[]}],"git":{"createdTime":1761407721000,"updatedTime":1761407721000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":1}]},"filePathRelative":"blogs/rust/2025/rust泛型.md"}');export{i as comp,u as data};
