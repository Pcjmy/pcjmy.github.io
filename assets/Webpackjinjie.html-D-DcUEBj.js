import{_ as a,c as l,a as i,o as n}from"./app-DyHmJYok.js";const s={};function p(c,e){return n(),l("div",null,[...e[0]||(e[0]=[i(`<h1 id="webpack进阶" tabindex="-1"><a class="header-anchor" href="#webpack进阶"><span>Webpack进阶</span></a></h1><h2 id="webpack运行时" tabindex="-1"><a class="header-anchor" href="#webpack运行时"><span>Webpack运行时</span></a></h2><p>为了正常、正确运行业务项目，Webpack 需要将开发者编写的业务代码以及支撑、调配这些业务代码的运行时一并打包到产物(bundle)中。</p><p>大多数 Webpack 特性都需要运行时才能跑起来，比如说：</p><ul><li>异步按需加载</li><li>HMR</li><li>WASM</li><li>Module Federation</li></ul><h3 id="运行时代码" tabindex="-1"><a class="header-anchor" href="#运行时代码"><span>运行时代码</span></a></h3><ul><li><code>__webpack_modules__</code> 对象，包含了除入口外的所有模块</li><li><code>__webpack_module_cache__</code> 对象，用于存储被引用过的模块</li><li><code>__webpack_require__</code> 函数，实现模块引用(require) 逻辑</li><li><code>__webpack_require__.d</code> ，工具函数，实现将模块导出的内容附加的模块对象上</li><li><code>__webpack_require__.o</code> ，工具函数，判断对象属性用</li><li><code>__webpack_require__.r</code> ，工具函数，在 ESM 模式下声明 ESM 模块标识</li></ul><h3 id="异步模块加载" tabindex="-1"><a class="header-anchor" href="#异步模块加载"><span>异步模块加载</span></a></h3><p>使用异步模块加载特性时，会额外增加如下运行时：</p><ul><li><code>__webpack_require__.e</code> ：逻辑上包裹了一层中间件模式与 promise.all ，用于异步加载多个模块</li><li><code>__webpack_require__.f</code> ：供 <strong>webpack_require</strong>.e 使用的中间件对象，例如使用 Module Federation 特性时就需要在这里注册中间件以修改 e 函数的执行逻辑</li><li><code>__webpack_require__.u</code> ：用于拼接异步模块名称的函数</li><li><code>__webpack_require__.l</code> ：基于 JSONP 实现的异步模块加载函数</li><li><code>__webpack_require__.p</code> ：当前文件的完整 URL，可用于计算异步模块的实际 URL</li></ul><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h3><p>一些重要规则：</p><ul><li>除了业务代码外，bundle 中还必须包含运行时代码才能正常运行</li><li>运行时的具体内容由业务代码，确切地说由业务代码所使用到的特性决定，例如使用到异步加载时需要打包 <strong>webpack_require</strong>.e 函数，那么这里面必然有一个运行时依赖收集的过程</li><li>开发者编写的业务代码会被包裹进恰当的运行时函数中，实现整体协调</li></ul><p>落到 Webpack 源码实现上，运行时的生成逻辑可以划分为两个步骤：</p><ul><li>依赖收集：遍历业务代码模块收集模块的特性依赖，从而确定整个项目对 Webpack runtime 的依赖列表</li><li>生成：合并 runtime 的依赖列表，打包到最终输出的 bundle</li></ul><h2 id="tree-shaking" tabindex="-1"><a class="header-anchor" href="#tree-shaking"><span>Tree Shaking</span></a></h2><p>Tree-Shaking 是一种基于 ES Module 规范的 Dead Code Elimination 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。</p><p>Tree Shaking 较早前由 Rich Harris 在 Rollup 中率先实现，Webpack 自 2.0 版本开始接入，至今已经成为一种应用广泛的性能优化手段。</p><h3 id="在-webpack-中启动-tree-shaking" tabindex="-1"><a class="header-anchor" href="#在-webpack-中启动-tree-shaking"><span>在 Webpack 中启动 Tree Shaking</span></a></h3><ul><li>使用 ESM 规范编写模块代码</li><li>配置 optimization.usedExports 为 true，启动标记功能</li><li>启动代码优化功能，可以通过如下方式实现： <ul><li>配置 mode = production</li><li>配置 optimization.minimize = true</li><li>提供 optimization.minimizer 数组</li></ul></li></ul><h3 id="理论基础" tabindex="-1"><a class="header-anchor" href="#理论基础"><span>理论基础</span></a></h3><p>在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的。</p><p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量。</p><p>所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p><h3 id="实现原理-1" tabindex="-1"><a class="header-anchor" href="#实现原理-1"><span>实现原理</span></a></h3><p>Webpack 中，Tree-shaking 的实现一是先标记出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：</p><ul><li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</li><li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句</li></ul><h2 id="持久化缓存" tabindex="-1"><a class="header-anchor" href="#持久化缓存"><span>持久化缓存</span></a></h2><p>Webpack 在第 5 个大版本引入持久化缓存，提升运行性能。它能够将首次构建结果持久化到本地文件系统，在下次执行构建时跳过一系列解析、链接、编译等非常消耗性能的操作，直接复用 module、chunk 的构建结果。</p><p>配置持久化缓存：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">//...</span></span>
<span class="line">  <span class="token literal-property property">cache</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;filesystem&#39;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token comment">//...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>Webpack5 会将首次构建出的 Module、Chunk、ModuleGraph 等对象序列化后保存到硬盘中，后面再运行的时候就可以跳过一些耗时的编译动作，直接复用缓存信息。</p><p>Webpack 的构建过程大致上可划分为三个阶段：</p><ul><li>初始化，主要是根据配置信息设置内置的各类插件</li><li>Make - 构建阶段，从 entry 模块开始，执行： <ul><li>读入文件内容</li><li>调用 Loader 转译文件内容</li><li>调用 acorn 生成 AST 结构</li><li>分析 AST，确定模块依赖列表</li><li>遍历模块依赖列表，对每一个依赖模块重新执行上述流程，直到生成完整的模块依赖图 —— ModuleGraph 对象</li></ul></li><li>Seal - 生成阶段，过程： <ul><li>代码转译，如 import 转换为 require 调用</li><li>分析运行时依赖</li><li>遍历模块依赖图，对每一个模块执行：</li><li>合并模块代码与运行时代码，生成 chunk</li><li>执行产物优化操作，如 Tree-shaking</li><li>将最终结果写出到产物文件</li></ul></li></ul><p>过程中存在许多 CPU 密集型操作，例如调用 Loader 链加载文件时，遇到 babel-loader、eslint-loader、ts-loader 等工具时可能需要重复生成 AST；分析模块依赖信息时则需要遍历 AST，执行大量运算；Seal 阶段也同样存在大量 AST 遍历，以及代码转换、优化操作，等等。</p><h3 id="实现缓存" tabindex="-1"><a class="header-anchor" href="#实现缓存"><span>实现缓存</span></a></h3><p>在引入持久化缓存之前，Webpack 在每次运行时都需要对所有模块完整执行上述构建流程，假设业务项目中有 1000 个文件，则每次执行 <code>npx webpack</code> 命令时都需要从 0 开始执行 1000 次构建、生成逻辑。</p><p>而 Webpack5 的持久化缓存功能则尝试将构建结果保存到文件系统中，在下次编译时对比每一个文件的内容哈希或时间戳，未发生变化的文件跳过编译操作，直接使用缓存副本，减少重复计算；发生变更的模块则重新执行编译流程。</p>`,39)])])}const t=a(s,[["render",p],["__file","Webpackjinjie.html.vue"]]),o=JSON.parse('{"path":"/blogs/Webpack/2025/Webpackjinjie.html","title":"Webpack进阶","lang":"en-US","frontmatter":{"title":"Webpack进阶","date":"2025-02-06T00:00:00.000Z","tags":["Webpack"],"categories":["Webpack"]},"headers":[{"level":2,"title":"Webpack运行时","slug":"webpack运行时","link":"#webpack运行时","children":[{"level":3,"title":"运行时代码","slug":"运行时代码","link":"#运行时代码","children":[]},{"level":3,"title":"异步模块加载","slug":"异步模块加载","link":"#异步模块加载","children":[]},{"level":3,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]}]},{"level":2,"title":"Tree Shaking","slug":"tree-shaking","link":"#tree-shaking","children":[{"level":3,"title":"在 Webpack 中启动 Tree Shaking","slug":"在-webpack-中启动-tree-shaking","link":"#在-webpack-中启动-tree-shaking","children":[]},{"level":3,"title":"理论基础","slug":"理论基础","link":"#理论基础","children":[]},{"level":3,"title":"实现原理","slug":"实现原理-1","link":"#实现原理-1","children":[]}]},{"level":2,"title":"持久化缓存","slug":"持久化缓存","link":"#持久化缓存","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"实现缓存","slug":"实现缓存","link":"#实现缓存","children":[]}]}],"git":{"createdTime":1738855614000,"updatedTime":1739286399000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":2}]},"filePathRelative":"blogs/Webpack/2025/Webpack进阶.md"}');export{t as comp,o as data};
