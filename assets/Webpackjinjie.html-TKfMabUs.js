import{_ as i,c as a,a as l,o as r}from"./app-Dgm3qbd6.js";const c={};function n(p,e){return r(),a("div",null,e[0]||(e[0]=[l('<h1 id="webpack进阶" tabindex="-1"><a class="header-anchor" href="#webpack进阶"><span>Webpack进阶</span></a></h1><h2 id="webpack运行时" tabindex="-1"><a class="header-anchor" href="#webpack运行时"><span>Webpack运行时</span></a></h2><p>为了正常、正确运行业务项目，Webpack 需要将开发者编写的业务代码以及支撑、调配这些业务代码的运行时一并打包到产物(bundle)中。</p><p>大多数 Webpack 特性都需要运行时才能跑起来，比如说：</p><ul><li>异步按需加载</li><li>HMR</li><li>WASM</li><li>Module Federation</li></ul><h3 id="运行时代码" tabindex="-1"><a class="header-anchor" href="#运行时代码"><span>运行时代码</span></a></h3><ul><li><code>__webpack_modules__</code> 对象，包含了除入口外的所有模块</li><li><code>__webpack_module_cache__</code> 对象，用于存储被引用过的模块</li><li><code>__webpack_require__</code> 函数，实现模块引用(require) 逻辑</li><li><code>__webpack_require__.d</code> ，工具函数，实现将模块导出的内容附加的模块对象上</li><li><code>__webpack_require__.o</code> ，工具函数，判断对象属性用</li><li><code>__webpack_require__.r</code> ，工具函数，在 ESM 模式下声明 ESM 模块标识</li></ul><h3 id="异步模块加载" tabindex="-1"><a class="header-anchor" href="#异步模块加载"><span>异步模块加载</span></a></h3><p>使用异步模块加载特性时，会额外增加如下运行时：</p><ul><li><code>__webpack_require__.e</code> ：逻辑上包裹了一层中间件模式与 promise.all ，用于异步加载多个模块</li><li><code>__webpack_require__.f</code> ：供 <strong>webpack_require</strong>.e 使用的中间件对象，例如使用 Module Federation 特性时就需要在这里注册中间件以修改 e 函数的执行逻辑</li><li><code>__webpack_require__.u</code> ：用于拼接异步模块名称的函数</li><li><code>__webpack_require__.l</code> ：基于 JSONP 实现的异步模块加载函数</li><li><code>__webpack_require__.p</code> ：当前文件的完整 URL，可用于计算异步模块的实际 URL</li></ul><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h3><p>一些重要规则：</p><ul><li>除了业务代码外，bundle 中还必须包含运行时代码才能正常运行</li><li>运行时的具体内容由业务代码，确切地说由业务代码所使用到的特性决定，例如使用到异步加载时需要打包 <strong>webpack_require</strong>.e 函数，那么这里面必然有一个运行时依赖收集的过程</li><li>开发者编写的业务代码会被包裹进恰当的运行时函数中，实现整体协调</li></ul><p>落到 Webpack 源码实现上，运行时的生成逻辑可以划分为两个步骤：</p><ul><li>依赖收集：遍历业务代码模块收集模块的特性依赖，从而确定整个项目对 Webpack runtime 的依赖列表</li><li>生成：合并 runtime 的依赖列表，打包到最终输出的 bundle</li></ul><h2 id="tree-shaking" tabindex="-1"><a class="header-anchor" href="#tree-shaking"><span>Tree Shaking</span></a></h2><p>Tree-Shaking 是一种基于 ES Module 规范的 Dead Code Elimination 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。</p><p>Tree Shaking 较早前由 Rich Harris 在 Rollup 中率先实现，Webpack 自 2.0 版本开始接入，至今已经成为一种应用广泛的性能优化手段。</p><h3 id="在-webpack-中启动-tree-shaking" tabindex="-1"><a class="header-anchor" href="#在-webpack-中启动-tree-shaking"><span>在 Webpack 中启动 Tree Shaking</span></a></h3><ul><li>使用 ESM 规范编写模块代码</li><li>配置 optimization.usedExports 为 true，启动标记功能</li><li>启动代码优化功能，可以通过如下方式实现： <ul><li>配置 mode = production</li><li>配置 optimization.minimize = true</li><li>提供 optimization.minimizer 数组</li></ul></li></ul><h3 id="理论基础" tabindex="-1"><a class="header-anchor" href="#理论基础"><span>理论基础</span></a></h3><p>在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的。</p><p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量。</p><p>所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p><h3 id="实现原理-1" tabindex="-1"><a class="header-anchor" href="#实现原理-1"><span>实现原理</span></a></h3><p>Webpack 中，Tree-shaking 的实现一是先标记出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：</p><ul><li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</li><li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句</li></ul>',27)]))}const d=i(c,[["render",n],["__file","Webpackjinjie.html.vue"]]),o=JSON.parse('{"path":"/blogs/Webpack/2025/Webpackjinjie.html","title":"Webpack进阶","lang":"en-US","frontmatter":{"title":"Webpack进阶","date":"2025-02-06T00:00:00.000Z","tags":["Webpack"],"categories":["Webpack"]},"headers":[{"level":2,"title":"Webpack运行时","slug":"webpack运行时","link":"#webpack运行时","children":[{"level":3,"title":"运行时代码","slug":"运行时代码","link":"#运行时代码","children":[]},{"level":3,"title":"异步模块加载","slug":"异步模块加载","link":"#异步模块加载","children":[]},{"level":3,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]}]},{"level":2,"title":"Tree Shaking","slug":"tree-shaking","link":"#tree-shaking","children":[{"level":3,"title":"在 Webpack 中启动 Tree Shaking","slug":"在-webpack-中启动-tree-shaking","link":"#在-webpack-中启动-tree-shaking","children":[]},{"level":3,"title":"理论基础","slug":"理论基础","link":"#理论基础","children":[]},{"level":3,"title":"实现原理","slug":"实现原理-1","link":"#实现原理-1","children":[]}]}],"git":{"createdTime":1738855614000,"updatedTime":1738855614000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":1}]},"filePathRelative":"blogs/Webpack/2025/Webpack进阶.md"}');export{d as comp,o as data};
