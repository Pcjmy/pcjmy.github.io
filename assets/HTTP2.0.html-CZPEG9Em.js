import{_ as l,c as e,a,o as i}from"./app-DyHmJYok.js";const n={};function r(s,t){return i(),e("div",null,[...t[0]||(t[0]=[a('<h1 id="http2-0" tabindex="-1"><a class="header-anchor" href="#http2-0"><span>HTTP2.0</span></a></h1><h2 id="http1-1协议的性能问题" tabindex="-1"><a class="header-anchor" href="#http1-1协议的性能问题"><span>HTTP1.1协议的性能问题</span></a></h2><p>现在的站点相比以前变化太多了，比如：</p><ul><li><strong>消息的大小变大了</strong>，从几 KB 大小的消息，到几 MB 大小的消息；</li><li><strong>页面资源变多了</strong>，从每个页面不到 10 个的资源，到每页超 100 多个资源；</li><li><strong>内容形式变多样了</strong>，从单纯到文本内容，到图片、视频、音频等内容；</li><li><strong>实时性要求变高了</strong>，对页面的实时性要求的应用越来越多；</li></ul><p>这些变化带来的最大性能问题就是 HTTP1.1 的高延迟，延迟高必然影响的就是用户体验。主要原因如下几个：</p><ul><li><strong>延迟难以下降</strong>，虽然现在网络的带宽相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li><li><strong>并发连接有限</strong>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li><li><strong>队头阻塞问题</strong>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li><li><strong>HTTP 头部巨大且重复</strong>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；</li><li><strong>不支持服务器推送消息</strong>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li></ul><h2 id="http2-0简介" tabindex="-1"><a class="header-anchor" href="#http2-0简介"><span>HTTP2.0简介</span></a></h2><ul><li>针对 HTTP1.1 的不足进行改进和优化，就有了 HTTP2 协议</li><li>HTTP2 在底层做了很多改进和优化，但在语义上兼容 HTTP1.1</li><li>升级到 HTTP2，客户端和服务器端几乎不需要修改代码</li><li>升级到 HTTP2，需要浏览器和服务器都支持</li><li>浏览器要求 HTTP2 必须基于 SSL/TLS</li><li>所有的请求/响应都可以在一个TCP 连接上完成</li><li>以帧(frame)的方式传输数据</li><li>把首部封装成首部帧，主体部封装成数据帧，每个帧都有标识符</li><li>不同请求/响应的帧可以在 TCP 连接上交错传输，接收后根据标识符组装</li><li>请求和对应的响应使用相同的标识符ID</li></ul><h2 id="http2-0特点" tabindex="-1"><a class="header-anchor" href="#http2-0特点"><span>HTTP2.0特点</span></a></h2><h3 id="多路复用和优先级" tabindex="-1"><a class="header-anchor" href="#多路复用和优先级"><span>多路复用和优先级</span></a></h3><p>HTTP2.0 实现了 Stream 并发，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧 1 -&gt; B 请求帧 1 -&gt; A 请求帧 2 -&gt; B 请求帧2，但是同一个 Stream 里的帧必须严格有序。</p><p>另外，可以根据资源的渲染顺序来设置 Stream 的优先级，从而提高用户体验。</p><h3 id="首部压缩" tabindex="-1"><a class="header-anchor" href="#首部压缩"><span>首部压缩</span></a></h3><p>对于常见的 HTTP 头部通过静态表和 Huffman 编码的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立动态表，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。</p><p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP/2 连接时长或者请求次数。</p><h3 id="服务器推送" tabindex="-1"><a class="header-anchor" href="#服务器推送"><span>服务器推送</span></a></h3><p>服务器支持主动推送资源，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。</p>',17)])])}const h=l(n,[["render",r],["__file","HTTP2.0.html.vue"]]),o=JSON.parse('{"path":"/blogs/jisuanjiwangluo/2025/HTTP2.0.html","title":"HTTP2.0","lang":"en-US","frontmatter":{"title":"HTTP2.0","date":"2025-01-18T00:00:00.000Z","tags":["HTTP"],"categories":["计算机网络"]},"headers":[{"level":2,"title":"HTTP1.1协议的性能问题","slug":"http1-1协议的性能问题","link":"#http1-1协议的性能问题","children":[]},{"level":2,"title":"HTTP2.0简介","slug":"http2-0简介","link":"#http2-0简介","children":[]},{"level":2,"title":"HTTP2.0特点","slug":"http2-0特点","link":"#http2-0特点","children":[{"level":3,"title":"多路复用和优先级","slug":"多路复用和优先级","link":"#多路复用和优先级","children":[]},{"level":3,"title":"首部压缩","slug":"首部压缩","link":"#首部压缩","children":[]},{"level":3,"title":"服务器推送","slug":"服务器推送","link":"#服务器推送","children":[]}]}],"git":{"createdTime":1737196333000,"updatedTime":1739113927000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":2}]},"filePathRelative":"blogs/计算机网络/2025/HTTP2.0.md"}');export{h as comp,o as data};
