import{_ as l,c as n,a as e,o as t}from"./app-DyHmJYok.js";const a={};function i(r,s){return t(),n("div",null,[...s[0]||(s[0]=[e(`<h1 id="https" tabindex="-1"><a class="header-anchor" href="#https"><span>HTTPS</span></a></h1><p>HTTPS（HyperText Transfer Protocol Secure）是HTTP的安全版本，通过<strong>TLS/SSL协议</strong>对传输数据进行加密和身份验证，确保通信过程的安全性。以下是HTTPS请求的详细流程：</p><hr><h3 id="_1-建立tcp连接-三次握手" tabindex="-1"><a class="header-anchor" href="#_1-建立tcp连接-三次握手"><span><strong>1. 建立TCP连接（三次握手）</strong></span></a></h3><ul><li><strong>客户端</strong>向服务器发起TCP连接请求（SYN包）。</li><li><strong>服务器</strong>返回确认响应（SYN-ACK包）。</li><li><strong>客户端</strong>发送最终确认（ACK包），完成三次握手，建立TCP连接。</li></ul><hr><h3 id="_2-tls-ssl握手-关键安全步骤" tabindex="-1"><a class="header-anchor" href="#_2-tls-ssl握手-关键安全步骤"><span><strong>2. TLS/SSL握手（关键安全步骤）</strong></span></a></h3><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实 就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私 钥不能被窃取。</p><p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对 称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它 加密应用消息。</p><p>一共经历了四次握手。</p><h4 id="_1-tls第一次握手" tabindex="-1"><a class="header-anchor" href="#_1-tls第一次握手"><span><strong>(1) TLS第一次握手</strong></span></a></h4><ul><li>客户端发起安全请求（ClientHello）</li><li>客户端发送支持的<strong>TLS版本</strong>、<strong>加密套件列表</strong>（如RSA、ECDHE）、<strong>随机数</strong>（Client Random）等信息。</li></ul><h4 id="_2-tls第二次握手" tabindex="-1"><a class="header-anchor" href="#_2-tls第二次握手"><span><strong>(2) TLS第二次握手</strong></span></a></h4><ul><li>服务器响应（ServerHello）</li><li>服务器选择<strong>加密套件</strong>（如TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384），并返回： <ul><li><strong>数字证书</strong>（包含公钥、域名、颁发机构等信息）。</li><li><strong>随机数</strong>（Server Random）。</li><li>（可选）要求客户端提供证书（双向认证）。</li></ul></li></ul><h4 id="_3-客户端验证证书" tabindex="-1"><a class="header-anchor" href="#_3-客户端验证证书"><span><strong>(3) 客户端验证证书</strong></span></a></h4><ul><li>客户端检查证书的<strong>有效性</strong>： <ul><li>证书是否由可信的CA（证书颁发机构）签发。</li><li>证书是否在有效期内。</li><li>证书中的域名是否与访问的域名匹配。</li></ul></li><li>如果证书无效（如自签名或过期），浏览器会警告用户。</li></ul><h4 id="_4-tls第三次握手" tabindex="-1"><a class="header-anchor" href="#_4-tls第三次握手"><span><strong>(4) TLS第三次握手</strong></span></a></h4><ul><li>密钥交换 <ul><li>客户端生成<strong>预主密钥（Pre-Master Secret）</strong>，用服务器的公钥加密后发送给服务器。</li><li>服务器用私钥解密，得到预主密钥。</li></ul></li><li>生成会话密钥 <ul><li>客户端和服务器通过<strong>Client Random</strong>、<strong>Server Random</strong>和<strong>Pre-Master Secret</strong>，使用相同算法生成<strong>对称加密的会话密钥</strong>（Session Key）。</li></ul></li><li>生成完会话密钥后，然后客户端发一个Change Cipher Spec，告诉服务端开始使用加密方式发送消息。</li><li>客户端再发一个Encrypted Handshake Message（Finishd）消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</li></ul><h4 id="_5-tls第四次握手" tabindex="-1"><a class="header-anchor" href="#_5-tls第四次握手"><span><strong>(5) TLS第四次握手</strong></span></a></h4><ul><li>服务器也是同样的操作，发Change Cipher Spec和Encrypted Handshake Message消息，如果双方都验证加密和解密没问题，那么握手正式完成。</li><li>最后，就用会话密钥加解密 HTTP 请求和响应了。</li></ul><hr><h3 id="_3-https数据传输" tabindex="-1"><a class="header-anchor" href="#_3-https数据传输"><span><strong>3. HTTPS数据传输</strong></span></a></h3><ul><li>客户端发送加密的<strong>HTTP请求</strong>（如GET/POST）。</li><li>服务器解密请求后处理，返回加密的<strong>HTTP响应</strong>（如HTML、JSON）。</li><li>客户端解密响应数据并渲染。</li></ul><hr><h3 id="_4-断开连接-四次挥手" tabindex="-1"><a class="header-anchor" href="#_4-断开连接-四次挥手"><span><strong>4. 断开连接（四次挥手）</strong></span></a></h3><ul><li>客户端或服务器发送断开请求（FIN包）。</li><li>双方确认关闭连接，释放资源。</li></ul><hr><h3 id="🔐-核心安全机制" tabindex="-1"><a class="header-anchor" href="#🔐-核心安全机制"><span><strong>🔐 核心安全机制</strong></span></a></h3><ol><li><p><strong>加密传输</strong></p><ul><li>对称加密（如AES）加密数据，速度快。</li><li>非对称加密（如RSA/ECC）用于安全交换对称密钥。</li></ul></li><li><p><strong>身份验证</strong></p><ul><li>数字证书验证服务器身份，防止中间人攻击。</li></ul></li><li><p><strong>完整性校验</strong></p><ul><li>使用MAC（消息认证码）或HMAC防止数据篡改。</li></ul></li></ol><hr><h3 id="🌐-示例流程" tabindex="-1"><a class="header-anchor" href="#🌐-示例流程"><span><strong>🌐 示例流程</strong></span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">客户端 → 服务器：TCP三次握手  </span>
<span class="line">客户端 → 服务器：ClientHello（TLS版本、加密套件、Client Random）  </span>
<span class="line">服务器 → 客户端：ServerHello（加密套件、Server Random、证书）  </span>
<span class="line">客户端 → 服务器：加密的Pre-Master Secret  </span>
<span class="line">客户端 ↔ 服务器：生成Session Key  </span>
<span class="line">客户端 → 服务器：加密的HTTP请求  </span>
<span class="line">服务器 → 客户端：加密的HTTP响应  </span>
<span class="line">客户端 ↔ 服务器：四次挥手断开连接</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>通过以上流程，HTTPS实现了<strong>数据加密</strong>、<strong>身份认证</strong>和<strong>完整性保护</strong>，成为现代Web安全的基石。</p>`,34)])])}const h=l(a,[["render",i],["__file","HTTPS.html.vue"]]),g=JSON.parse('{"path":"/blogs/jisuanjiwangluo/2025/HTTPS.html","title":"HTTPS","lang":"en-US","frontmatter":{"title":"HTTPS","date":"2025-02-01T00:00:00.000Z","tags":["HTTP"],"categories":["计算机网络"]},"headers":[{"level":3,"title":"1. 建立TCP连接（三次握手）","slug":"_1-建立tcp连接-三次握手","link":"#_1-建立tcp连接-三次握手","children":[]},{"level":3,"title":"2. TLS/SSL握手（关键安全步骤）","slug":"_2-tls-ssl握手-关键安全步骤","link":"#_2-tls-ssl握手-关键安全步骤","children":[]},{"level":3,"title":"3. HTTPS数据传输","slug":"_3-https数据传输","link":"#_3-https数据传输","children":[]},{"level":3,"title":"4. 断开连接（四次挥手）","slug":"_4-断开连接-四次挥手","link":"#_4-断开连接-四次挥手","children":[]},{"level":3,"title":"🔐 核心安全机制","slug":"🔐-核心安全机制","link":"#🔐-核心安全机制","children":[]},{"level":3,"title":"🌐 示例流程","slug":"🌐-示例流程","link":"#🌐-示例流程","children":[]}],"git":{"createdTime":1738423466000,"updatedTime":1739089406000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":4}]},"filePathRelative":"blogs/计算机网络/2025/HTTPS.md"}');export{h as comp,g as data};
