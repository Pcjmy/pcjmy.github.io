import{_ as a,c as i,a as e,o as n}from"./app-DyHmJYok.js";const t={};function s(r,l){return n(),i("div",null,[...l[0]||(l[0]=[e('<h1 id="前端模块化" tabindex="-1"><a class="header-anchor" href="#前端模块化"><span>前端模块化</span></a></h1><h2 id="前端模块化的背景" tabindex="-1"><a class="header-anchor" href="#前端模块化的背景"><span>前端模块化的背景</span></a></h2><ul><li>前端模块化是一种标准，不是实现</li><li>理解模块化是理解前端工程化的前提</li><li>前端模块化是前端项目规模化的必然结果</li></ul><h2 id="什么是前端模块化" tabindex="-1"><a class="header-anchor" href="#什么是前端模块化"><span>什么是前端模块化</span></a></h2><ul><li>将复杂程序根据规范拆分成若干模块,一个模块包括输入和输出</li><li>模块的内部实现是私有的，对外暴露接口与其它模块通信</li><li>一个HTML页面可以引用的script包括：脚本和模块</li></ul><h2 id="前端模块化的进化过程" tabindex="-1"><a class="header-anchor" href="#前端模块化的进化过程"><span>前端模块化的进化过程</span></a></h2><ul><li>第一阶段：全局function模式，将不同功能封装成不同函数</li></ul><p>缺陷：容易引发全局命名空间冲突</p><ul><li>第二阶段：全局namespace模式，通过对象封装模块</li></ul><p>缺陷：外部能够修改模块内部数据</p><ul><li>第三阶段：IIFE模式，通过自执行函数创建闭包</li></ul><p>缺陷：无法解决模块间相互依赖问题</p><ul><li>第四阶段：IIFE模式增强，支持传入自定义依赖</li></ul><p>缺陷：</p><ol><li><p>多依赖传入时，代码阅读困难</p></li><li><p>无法支持大规模的模块化开发</p></li><li><p>无特定语法支持，代码简陋</p></li></ol>',15)])])}const h=a(t,[["render",s],["__file","qianduanmokuaihua.html.vue"]]),o=JSON.parse('{"path":"/blogs/qianduangongchenghua/2024/qianduanmokuaihua.html","title":"前端模块化","lang":"en-US","frontmatter":{"title":"前端模块化","date":"2024-09-22T00:00:00.000Z","tags":["前端模块化"],"categories":["前端工程化"]},"headers":[{"level":2,"title":"前端模块化的背景","slug":"前端模块化的背景","link":"#前端模块化的背景","children":[]},{"level":2,"title":"什么是前端模块化","slug":"什么是前端模块化","link":"#什么是前端模块化","children":[]},{"level":2,"title":"前端模块化的进化过程","slug":"前端模块化的进化过程","link":"#前端模块化的进化过程","children":[]}],"git":{"createdTime":1727019156000,"updatedTime":1768665336000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":1}]},"filePathRelative":"blogs/前端工程化/2024/前端模块化.md"}');export{h as comp,o as data};
