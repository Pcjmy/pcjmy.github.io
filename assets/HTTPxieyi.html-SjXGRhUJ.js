import{_ as n,c as e,a as l,o as a}from"./app-DyHmJYok.js";const t={};function i(r,s){return a(),e("div",null,[...s[0]||(s[0]=[l(`<h2 id="http-协议" tabindex="-1"><a class="header-anchor" href="#http-协议"><span>HTTP 协议</span></a></h2><ul><li>HTTP 是什么</li><li>HTTP 请求响应的过程</li></ul><p>HyperText Transfer Protocol 超文本传输协议</p><p>HTTP 是一个请求-响应协议</p><p>HTML、JS、CSS、图片、字体、音频、视频等等文件，都是通过 HTTP(超文本传输协议)在服务器和浏览器之间传输</p><h3 id="http-报文" tabindex="-1"><a class="header-anchor" href="#http-报文"><span>HTTP 报文</span></a></h3><p>1.HTTP 报文是什么</p><p>浏览器向服务器发送请求时，请求本身就是信息，叫请求报文</p><p>服务器向浏览器发送响应时传输的信息，叫响应报文</p><p>2.HTTP 报文格式</p><p>请求</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">请求头：起始行<span class="token operator">+</span>首部</span>
<span class="line">请求体</span>
<span class="line"><span class="token constant">GET</span> 请求，没有请求体，数据通过请求头携带</span>
<span class="line"><span class="token constant">POST</span> 请求，有请求体，数据通过请求体携带</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>响应</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">响应头：起始行<span class="token operator">+</span>首部</span>
<span class="line">响应体</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="http-状态码" tabindex="-1"><a class="header-anchor" href="#http-状态码"><span>HTTP 状态码</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token number">1.</span><span class="token constant">HTTP</span> 状态码是什么</span>
<span class="line">定义服务器对请求的处理结果，是服务器返回的</span>
<span class="line"></span>
<span class="line"><span class="token number">2.</span><span class="token constant">HTTP</span> 状态码的语义</span>
<span class="line"><span class="token number">100</span><span class="token operator">~</span><span class="token number">199</span> 消息：代表请求已被接受，需要继续处理</span>
<span class="line">websocket</span>
<span class="line"></span>
<span class="line"><span class="token number">200</span><span class="token operator">~</span><span class="token number">299</span> 成功</span>
<span class="line"><span class="token number">200</span></span>
<span class="line"></span>
<span class="line"><span class="token number">300</span><span class="token operator">~</span><span class="token number">399</span> 重定向</span>
<span class="line"><span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">www.imooc.com</span><span class="token regex-delimiter">/</span></span></span>
<span class="line"><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">www.imooc.com</span><span class="token regex-delimiter">/</span></span></span>
<span class="line"></span>
<span class="line"><span class="token number">301</span> Moved Permanently</span>
<span class="line"><span class="token number">302</span> Move Temporarily</span>
<span class="line"></span>
<span class="line"><span class="token number">304</span> Not Modified</span>
<span class="line"></span>
<span class="line"><span class="token number">400</span><span class="token operator">~</span><span class="token number">499</span> 请求错误</span>
<span class="line"><span class="token number">404</span> Not Found</span>
<span class="line"></span>
<span class="line"><span class="token number">500</span><span class="token operator">~</span><span class="token number">599</span> 服务器错误</span>
<span class="line"><span class="token number">500</span> Internal Server Error</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HTTP 常见状态码及含义</p><ul><li>200 请求成功</li><li>301 永久重定向</li><li>302 临时重定向</li><li>403 没权限</li><li>404 表示服务器上没有找到该资源</li><li>500 服务器错误</li></ul><h3 id="http-方法" tabindex="-1"><a class="header-anchor" href="#http-方法"><span>HTTP 方法</span></a></h3><ul><li>常用的 HTTP 方法</li><li>HTTP 方法的语义</li><li>RESTful 接口设计</li></ul><p>1.常用的 HTTP 方法</p><p>GET、POST、PUT、DELETE</p><p>浏览器发送请求时采用的方法，和响应无关</p><p>用来定义对于资源采取什么样的操作的，有各自的语义</p><p>2.HTTP 方法的语义</p><ul><li>GET 获取数据</li><li>POST 创建数据</li><li>PUT 更新数据</li><li>DELETE 删除数据</li></ul><p><strong>增删改查</strong></p><p>这些方法虽然有各自的语义，但是并不是强制性的</p><p>3.RESTful 接口设计</p><p>一种接口设计风格，充分利用 HTTP 方法的语义</p><h3 id="get-和-post-方法的对比" tabindex="-1"><a class="header-anchor" href="#get-和-post-方法的对比"><span>GET 和 POST 方法的对比</span></a></h3><ul><li>语义</li><li>发送数据</li><li>缓存</li><li>安全性</li></ul><p>1.语义</p><p>GET：获取数据 POST：创建数据</p><p>2.发送数据</p><p>GET 通过地址在请求头中携带数据 能携带的数据量和地址的长度有关系，一般最多就几 K</p><p>POST 既可以通过地址在请求头中携带数据，也可以通过请求体携带数据 能携带的数据量理论上是无限的</p><p>携带少量数据，可以使用 GET 请求，大量的数据可以使用 POST 请求</p><p>3.缓存</p><p>GET 可以被缓存，POST 不会被缓存</p><p>4.安全性</p><p>?username=alex GET 和 POST 都不安全</p><p>发送密码或其他敏感信息时不要使用 GET，主要是避免直接被他人窥屏或通过历史记录找到你的密码</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">get用来获取数据，post用来提交数据</span>
<span class="line">get参数有长度限制<span class="token punctuation">(</span>受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节<span class="token punctuation">)</span>，而post无限制</span>
<span class="line">get是明文传输，post是放在请求体中</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="http-header" tabindex="-1"><a class="header-anchor" href="#http-header"><span>HTTP header</span></a></h3><p>http 协议中的 header 及含义</p><ul><li>accept：代表客户端希望接受的数据类型</li><li>accept-encoding：浏览器发给服务器，声明浏览器支持的编码类型</li><li>accept-language：表示浏览器所支持的语言类型</li><li>Cache-Control：缓存开关，no-cache 表示禁用缓存</li><li>referer：referer 的正确英语拼法是 referrer。由于早期 HTTP 规范的拼写错误，主要用于防止盗链和恶意请求</li></ul><h2 id="http版本" tabindex="-1"><a class="header-anchor" href="#http版本"><span>HTTP版本</span></a></h2><h3 id="http-0-9-1991年" tabindex="-1"><a class="header-anchor" href="#http-0-9-1991年"><span><strong>HTTP/0.9（1991年）</strong></span></a></h3><ul><li><strong>特点</strong>： <ul><li>仅支持 <code>GET</code> 方法，无请求头（Headers）或状态码。</li><li>响应只能是纯文本（HTML），无其他格式支持。</li><li>每个请求完成后立即关闭 TCP 连接。</li></ul></li><li><strong>局限性</strong>： <ul><li>功能极简，无法传输复杂内容或元数据。</li></ul></li></ul><hr><h3 id="http-1-0-1996年-rfc-1945" tabindex="-1"><a class="header-anchor" href="#http-1-0-1996年-rfc-1945"><span><strong>HTTP/1.0（1996年，RFC 1945）</strong></span></a></h3><ul><li><strong>核心改进</strong>： <ul><li>引入 <strong>请求方法</strong>：<code>GET</code>、<code>POST</code>、<code>HEAD</code> 等。</li><li>支持 <strong>状态码</strong>（如 <code>200 OK</code>、<code>404 Not Found</code>）。</li><li>新增 <strong>请求头/响应头</strong>，允许传输元数据（如 <code>Content-Type</code>、<code>User-Agent</code>）。</li><li>支持多种内容类型（如文本、图片、视频）。</li></ul></li><li><strong>问题</strong>： <ul><li>每个请求需新建 TCP 连接（短连接），性能差（<strong>三次握手开销大</strong>）。</li></ul></li></ul><hr><h3 id="http-1-1-1997年-rfc-2616-2014年修订为-rfc-7230-7235" tabindex="-1"><a class="header-anchor" href="#http-1-1-1997年-rfc-2616-2014年修订为-rfc-7230-7235"><span><strong>HTTP/1.1（1997年，RFC 2616；2014年修订为 RFC 7230-7235）</strong></span></a></h3><ul><li><strong>主要优化</strong>： <ul><li><strong>持久连接（Keep-Alive）</strong>：默认复用 TCP 连接，减少握手开销。</li><li><strong>管道化（Pipelining）</strong>：允许客户端发送多个请求后再按序接收响应（但存在队头阻塞问题）。</li><li><strong>分块传输编码（Chunked Transfer Encoding）</strong>：支持流式传输大文件。</li><li><strong>缓存控制</strong>：通过 <code>Cache-Control</code>、<code>ETag</code> 等头部优化缓存策略。</li><li>新增方法：<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>。</li></ul></li><li><strong>遗留问题</strong>： <ul><li>队头阻塞（Head-of-Line Blocking）：一个请求的延迟会影响后续请求。</li><li>头部冗余：重复传输未压缩的头部信息。</li></ul></li></ul><hr><h3 id="http-2-2015年-rfc-7540" tabindex="-1"><a class="header-anchor" href="#http-2-2015年-rfc-7540"><span><strong>HTTP/2（2015年，RFC 7540）</strong></span></a></h3><ul><li><strong>核心改进</strong>： <ul><li><strong>二进制分帧层</strong>：将数据分解为二进制帧传输，提升解析效率。</li><li><strong>多路复用（Multiplexing）</strong>：同一连接上并行传输多个请求/响应，彻底解决队头阻塞。</li><li><strong>头部压缩（HPACK）</strong>：减少头部数据体积（尤其对重复字段）。</li><li><strong>服务器推送（Server Push）</strong>：服务器可主动推送资源（如 CSS/JS）到客户端缓存。</li><li><strong>优先级控制</strong>：允许客户端指定请求优先级。</li></ul></li><li><strong>兼容性</strong>： <ul><li>兼容 HTTP/1.1 语义，需基于 HTTPS（加密传输）。</li></ul></li></ul><hr><h3 id="http-3-2022年-rfc-9114" tabindex="-1"><a class="header-anchor" href="#http-3-2022年-rfc-9114"><span><strong>HTTP/3（2022年，RFC 9114）</strong></span></a></h3><ul><li><strong>革命性变化</strong>： <ul><li><strong>基于 QUIC 协议</strong>：弃用 TCP，改用 UDP 作为传输层协议，减少握手延迟。</li><li><strong>解决队头阻塞</strong>：QUIC 在传输层实现多路复用，避免 TCP 的队头阻塞问题。</li><li><strong>连接迁移</strong>：切换网络时（如 Wi-Fi 转 4G），连接无需重建。</li><li><strong>内置加密</strong>：默认整合 TLS 1.3，强制加密通信。</li><li><strong>0-RTT 快速重连</strong>：复用时无需重新握手，提升速度。</li></ul></li><li><strong>挑战</strong>： <ul><li>需要服务器和客户端支持 QUIC（如 Chrome、Cloudflare 已广泛支持）。</li></ul></li></ul><hr><h3 id="版本对比" tabindex="-1"><a class="header-anchor" href="#版本对比"><span><strong>版本对比</strong></span></a></h3><table><thead><tr><th><strong>特性</strong></th><th>HTTP/1.1</th><th>HTTP/2</th><th>HTTP/3</th></tr></thead><tbody><tr><td><strong>传输层协议</strong></td><td>TCP</td><td>TCP</td><td>UDP（QUIC）</td></tr><tr><td><strong>多路复用</strong></td><td>支持（管道化，但有缺陷）</td><td>支持（二进制分帧）</td><td>支持（QUIC 原生多路复用）</td></tr><tr><td><strong>头部压缩</strong></td><td>无</td><td>HPACK</td><td>QPACK</td></tr><tr><td><strong>队头阻塞</strong></td><td>存在</td><td>应用层解决</td><td>传输层解决</td></tr><tr><td><strong>握手延迟</strong></td><td>高（3-RTT）</td><td>中（TLS 1.2+）</td><td>低（0-RTT 或 1-RTT）</td></tr><tr><td><strong>默认加密</strong></td><td>可选（HTTP/HTTPS）</td><td>需 HTTPS</td><td>强制加密</td></tr></tbody></table><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h3><ul><li><strong>HTTP/1.1</strong>：仍是主流，但性能受限于队头阻塞和头部冗余。</li><li><strong>HTTP/2</strong>：显著提升性能，需 HTTPS 支持，适用于现代高并发场景。</li><li><strong>HTTP/3</strong>：未来方向，通过 QUIC 解决延迟和可靠性问题，逐步普及中。</li></ul><p>理解 HTTP 版本演进有助于优化 Web 应用性能（如选择协议版本、配置服务器），并应对网络环境中的兼容性挑战。</p>`,69)])])}const o=n(t,[["render",i],["__file","HTTPxieyi.html.vue"]]),d=JSON.parse('{"path":"/blogs/jisuanjiwangluo/2022/HTTPxieyi.html","title":"HTTP协议","lang":"en-US","frontmatter":{"title":"HTTP协议","date":"2022-05-11T00:00:00.000Z","tags":["HTTP"],"categories":["计算机网络"]},"headers":[{"level":2,"title":"HTTP 协议","slug":"http-协议","link":"#http-协议","children":[{"level":3,"title":"HTTP 报文","slug":"http-报文","link":"#http-报文","children":[]},{"level":3,"title":"HTTP 状态码","slug":"http-状态码","link":"#http-状态码","children":[]},{"level":3,"title":"HTTP 方法","slug":"http-方法","link":"#http-方法","children":[]},{"level":3,"title":"GET 和 POST 方法的对比","slug":"get-和-post-方法的对比","link":"#get-和-post-方法的对比","children":[]},{"level":3,"title":"HTTP header","slug":"http-header","link":"#http-header","children":[]}]},{"level":2,"title":"HTTP版本","slug":"http版本","link":"#http版本","children":[{"level":3,"title":"HTTP/0.9（1991年）","slug":"http-0-9-1991年","link":"#http-0-9-1991年","children":[]},{"level":3,"title":"HTTP/1.0（1996年，RFC 1945）","slug":"http-1-0-1996年-rfc-1945","link":"#http-1-0-1996年-rfc-1945","children":[]},{"level":3,"title":"HTTP/1.1（1997年，RFC 2616；2014年修订为 RFC 7230-7235）","slug":"http-1-1-1997年-rfc-2616-2014年修订为-rfc-7230-7235","link":"#http-1-1-1997年-rfc-2616-2014年修订为-rfc-7230-7235","children":[]},{"level":3,"title":"HTTP/2（2015年，RFC 7540）","slug":"http-2-2015年-rfc-7540","link":"#http-2-2015年-rfc-7540","children":[]},{"level":3,"title":"HTTP/3（2022年，RFC 9114）","slug":"http-3-2022年-rfc-9114","link":"#http-3-2022年-rfc-9114","children":[]},{"level":3,"title":"版本对比","slug":"版本对比","link":"#版本对比","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1669638645000,"updatedTime":1738422477000,"contributors":[{"name":"Pcjmy","email":"1716045191@qq.com","commits":4}]},"filePathRelative":"blogs/计算机网络/2022/HTTP协议.md"}');export{o as comp,d as data};
